%Azimi This is "sig-alternate.tex" V2.0 May 2012
% This file should be compiled with V2.5 of "sig-alternate.cls" May 2012
%
% This example file demonstrates the use of the 'sig-alternate.cls'
% V2.5 LaTeX2e document class file. It is for those submitting
% articles to ACM Conference Proceedings WHO DO NOT WISH TO
% STRICTLY ADHERE TO THE SIGS (PUBS-BOARD-ENDORSED) STYLE.
% The 'sig-alternate.cls' file will produce a similar-looking,
% albeit, 'tighter' paper resulting in, invariably, fewer pages.
%
% ----------------------------------------------------------------------------------------------------------------
% This .tex file (and associated .cls V2.5) produces:
%       1) The Permission Statement
%       2) The Conference (location) Info information
%       3) The Copyright Line with ACM data
%       4) NO page numbers
%
% as against the acm_proc_article-sp.cls file which
% DOES NOT produce 1) thru' 3) above.
%
% Using 'sig-alternate.cls' you have control, however, from within
% the source .tex file, over both the CopyrightYear
% (defaulted to 200X) and the ACM Copyright Data
% (defaulted to X-XXXXX-XX-X/XX/XX).
% e.g.
% \CopyrightYear{2007} will cause 2007 to appear in the copyright line.
% \crdata{0-12345-67-8/90/12} will cause 0-12345-67-8/90/12 to appear in the copyright line.
%
% ---------------------------------------------------------------------------------------------------------------
% This .tex source is an example which *does* use
% the .bib file (from which the .bbl file % is produced).
% REMEMBER HOWEVER: After having produced the .bbl file,
% and prior to final submission, you *NEED* to 'insert'
% your .bbl file into your source .tex file so as to provide
% ONE 'self-contained' source file.
%
% ================= IF YOU HAVE QUESTIONS =======================
% Questions regarding the SIGS styles, SIGS policies and
% procedures, Conferences etc. should be sent to
% Adrienne Griscti (griscti@acm.org)
%
% Technical questions _only_ to
% Gerald Murray (murray@hq.acm.org)
% ===============================================================
%
% For tracking purposes - this is V2.0 - May 2012

\documentclass{sig-alternate}

\usepackage{code}
\usepackage{comment}
\usepackage{url}

\begin{document}
\conferenceinfo{ISSTA'15}{, July 12--17, 2015, Baltimore, MD, USA}
\CopyrightYear{2015}
\crdata{978-1-4503-3620-8/15/07}
%
% --- Author Metadata here ---
%\conferenceinfo{ISSTA}{'15 Baltimore, MA USA}
%\CopyrightYear{2007} % Allows default copyright year (20XX) to be over-ridden - IF NEED BE.
%\crdata{0-12345-67-8/90/01}  % Allows default copyright data (0-89791-88-6/97/05) to be over-ridden - IF NEED BE.
% --- End of Author Metadata ---

\title{TSTL: A Language and Tool for Testing (Demo)}
%
% You need the command \numberofauthors to handle the 'placement
% and alignment' of the authors beneath the title.
%
% For aesthetic reasons, we recommend 'three authors at a time'
% i.e. three 'name/affiliation blocks' be placed beneath the title.
%
% NOTE: You are NOT restricted in how many 'rows' of
% "name/affiliations" may appear. We just ask that you restrict
% the number of 'columns' to three.
%
% Because of the available 'opening page real-estate'
% we ask you to refrain from putting more than six authors
% (two rows with three columns) beneath the article title.
% More than six makes the first-page appear very cluttered indeed.
%
% Use the \alignauthor commands to handle the names
% and affiliations for an 'aesthetic maximum' of six authors.
% Add names, affiliations, addresses for
% the seventh etc. author(s) as the argument for the
% \additionalauthors command.
% These 'additional authors' will be output/set for you
% without further effort on your part as the last section in
% the body of your article BEFORE References or any Appendices.

\numberofauthors{1} %  in this sample file, there are a *total*
% of EIGHT authors. SIX appear on the 'first-page' (for formatting
% reasons) and the remaining two appear in the \additionalauthors section.
%
\author{
% You can go ahead and credit any number of authors here,
% e.g. one 'row of three' or two rows (consisting of one row of three
% and a second row of one, two or three).
%
% The command \alignauthor (no curly braces needed) should
% precede each author name, affiliation/snail-mail address and
% e-mail address. Additionally, tag each line of
% affiliation/address with \affaddr, and tag the
% e-mail address with \email.
%
% 1st. author
\alignauthor
Alex Groce, Jervis Pinto, Pooria Azimi, Pranjal Mittal \\
\affaddr{Oregon State University, USA}
\email{agroce@gmail.com,pinto@eecs.oregonstate.edu,\\
azimip@onid.oregonstate.edu,mittal.pranjal@gmail.com}
}
% There's nothing stopping you putting the seventh, eighth, etc.
% author on the opening page (as the 'third row') but we ask,
% for aesthetic reasons that you place these 'additional authors'
% in the \additional authors block, viz.
\additionalauthors{Additional authors: John Smith (The Th{\o}rv{\"a}ld Group,
email: {\texttt{jsmith@affiliation.org}}) and Julius P.~Kumquat
(The Kumquat Consortium, email: {\texttt{jpkumquat@consortium.net}}).}
\date{30 July 1999}
% Just remember to make sure that the TOTAL number of authors
% is the number that will appear on the first page PLUS the
% number that will appear in the \additionalauthors section.

\maketitle
\begin{abstract}

  Writing a test harness is a difficult and repetitive programming
  task, and the lack of tool support for customized automated testing
  is an obstacle to the adoption of more sophisticated testing in
  industry.  This paper presents TSTL, the Template Scripting Testing
  Language, which allows users to specify the general form of valid
  tests for a system in a simple but expressive language, and tools
  to support testing based on a TSTL definition.  TSTL is a minimalist
  template-based domain-specific language, using the source language
  of the Software Under Test (SUT) to support most operations, but
  adding declarative idioms for testing.  TSTL compiles to a common
  testing interface that hides the details of the SUT and provides
  support for logging, code coverage, delta debugging, and other core
  testing functionality, making it easy to write universal testing
  tools such as random testers or model checkers that apply to all
  TSTL-defined harnesses.  TSTL is currently available for
  Python, but easily adapted to other languages as well.

\end{abstract}

% A category with the (minimum) three required fields
%\category{H.4}{Information Systems Applications}{Miscellaneous}
%A category including the fourth, optional field follows...
\category{D.2.5}{Software Engineering}{Testing and Debugging}

\terms{Reliability}

\keywords{Domain-specific languages, testing tools, Python}

\section{Introduction}

Automated testing often requires a user to write a \emph{test harness}
--- essentially a program that defines and generates the set of valid
tests for the Software Under Test (SUT).  Such harnesses are common to
random testing, many kinds of model checking, and various
machine-learning influenced approaches \cite{woda12}.  Unfortunately,
these harnesses themselves are complex software artifacts and it is
all too easy to spend valuable testing time hunting down bugs in the
test harness and not the SUT.  Harness code is often highly repetitive
(choosing between a set of available API calls to make, and assigning
values to parameters in those calls, for example) and is almost always
tightly coupled to one particular test generation method.
TSTL \cite{NFM15} is a language and tool intended to make these
difficulties less onerous.

First, TSTL allows a harness to be defined in a declarative style, and
provides support for many common testing idioms.  Second, adapting a
more declarative approach allows TSTL to output a generalized
interface for testing: a class that allows a testing tool to determine
available test actions, check for success or failure of tests as they
progress, and even automatically produce logs, collect and analyze
code coverage, and delta-debug failed tests, without change for
different SUTs, but without sacrificing the generality of a hand-built
test generator: the definition of valid tests also encodes the
idiosyncrasies of the SUT.

Figure \ref{fig:avl} shows a simple TSTL file, defining valid tests of
an AVL tree implementation.  Most of the file is actually Python code.
TSTL compiles such a file into Python code defining a class for
testing tools to interface.  Figure \ref{fig:rt} shows an example of a
simple random tester using that interface, concise but featuring delta
debugging \cite{DD} and branch coverage reporting.  The key idea of TSTL is to
take a definition of valid actions (typically API calls) that can
be performed by the SUT and transform this into a class representing a
graph with transitions between the states produced by performing those
actions.  This allows us to separate the problem of describing the set
of valid tests of a program from the problem of actually choosing and
executing some of those tests.  
TSTL tracks code coverage, handles exceptions, and performs
other book-keeping (including providing easy-to-use state storage and
backtracking), resulting in a simple clean definition not only of
test harnesses but of algorithms for searching their induced test graphs.

\begin{figure}
\begin{code}
$_{01}$ @import avl
$_{02}$ @import math
\vspace{0.1in}
$_{03}$ <@
$_{04}$ def heightOk(tree):

$_{05}$     h = tree.tree\_height()
$_{06}$     l = len(tree.inorder())
$_{07}$     if (l == 0):
$_{08}$        return True
$_{09}$     m = math.log(l,2)
$_{10}$     \# Demonstrate PRE
$_{11}$     assert (PRE\%(tree.inorder())\% 
$_{12}$             == tree.inorder())
$_{13}$     return h <= (m + 1)
\vspace{0.1in}
$_{14}$ def it(s):
$_{15}$     l = []
$_{16}$     for i in s:
$_{17}$        l.append(i)
$_{18}$     return sorted(l)
$_{19}$ @>
\vspace{0.1in}
$_{20}$ source: avl.py
\vspace{0.1in}
$_{21}$ pool: %INT% 4
$_{22}$ pool: %AVL% 2 REF
$_{23}$ pool: %LIST% 2
\vspace{0.1in}
$_{24}$ log: 1 %AVL%.inorder()
\vspace{0.1in}
$_{25}$ property: heightOk(%AVL%) 
$_{26}$ property: %AVL%.check\_balanced()
\vspace{0.1in}
$_{27}$ %LIST%:=[]
$_{28}$ ~%LIST%.append(%INT%) 
$_{29}$ %INT%:=%[1..20]%
\vspace{0.1in}
$_{30}$ %AVL%:=avl.AVLTree()
$_{31}$ %AVL%:=avl.AVLTree(%LIST%)
\vspace{0.1in}

$_{32}$ ~%AVL%.insert(%INT%) => 
   (len(%AVL,1%.inorder()) ==
      PRE%(len(%AVL,1%.inorder()))%+1) 
   or PRE%(%AVL,1%.find(%INT,1%))%
$_{33}$ ~%AVL%.delete(%INT%) => 
   (len(%AVL,1%.inorder()) ==
      PRE%(len(%AVL,1%.inorder()))%-1) 
   or not PRE%((%AVL,1%.find(%INT,1%)))%
$_{34}$ ~%AVL%.find(%INT%)
$_{35}$ %AVL%.inorder()
$_{36}$ len(%AVL,1%.inorder()) > 5 -> 
   %AVL%.display()
\vspace{0.1in}
$_{37}$ reference: avl.AVLTree ==> set
$_{38}$ reference: insert ==> add
$_{39}$ reference: delete ==> discard
$_{40}$ reference: find ==> \_\_contains\_\_
$_{41}$ reference: (\\S+)\\.inorder\\(\\) ==> it(\\1)
$_{42}$ reference: METHOD(display) ==> CALL(print)
\vspace{0.1in}
$_{43}$ compare: find
$_{44}$ compare: inorder
\end{code}
\caption{Simple TSTL file to test an AVL tree class,
  showing various features of TSTL.  {\tt AVLTree} defines methods
  including {\tt insert}, {\tt delete}, {\tt find}, etc.}
\label{fig:avl}
\end{figure}

\begin{figure}
\begin{code}
import sut
import random

sut = sut.sut()

NUM\_TESTS = 1000
TEST\_LENGTH = 200 

for t in xrange(0,NUM\_TESTS):
   sut.restart()
   T = []
   for s in xrange(0,TEST\_LENGTH): 
       action = random.choice(sut.enabled())
       T.append(action)
       r = safely(action)
       if sut.newBranches() != []
          print 'NEW BRANCHES:'
          print sut.newBranches()
       if not r:
          print 'EXCEPTION:', sut.error() 
          R = sut.reduce(T, sut.fails) 
          print 'FAILING TEST:', R
       elif not sut.check():
          print 'PROPERTY FAILED:'
          print sut.error()  
          R = sut.reduce(T, sut.failsCheck) 
          print 'FAILING TEST:', R
\end{code}
\caption{A simple random tester using the interface provided by TSTL.}
\label{fig:rt}
\end{figure}

In this paper we demonstrate the current functionality of TSTL.  A
more detailed description of TSTL \cite{NFM15} is available elsewhere,
providing further information on the algorithm used to compile
(really, expand) TSTL harnesses, the core TSTL language in BNF, and
the design choices behind TSTL.  Since that paper was finalized, TSTL
has been used by over 100 students, and refined based on their
feedback and our own work in practical testing problems and research.
New features include the ability to refer to the value of an
expression at function entry with the construct {\tt PRE\%(expr)\%}, a
logging facility, support for serializing tests in order to save them
to a file, a method for expecting certain changes in values from a
call, and a generalized delta debugging \cite{DD} facility supporting
arbitrary properties (e.g., reducing a test case so it keeps the same
code coverage \cite{icst2014}) in addition to bug reduction.  While
this tool paper focuses on TSTL's use in API-call based testing, TSTL
can also support grammar-based testing, as shown in the NFM paper
\cite{NFM15}.  TSTL is available from github
(\url{https://github.com/agroce/tstl}) or as a package in Pypi.

\section{A Brief TSTL Tutorial}

We demonstrate TSTL's use to test an AVL tree implementaiton (Figure \ref{fig:avl}) as an example of a typical SUT.


\subsection{Section 1: Python Code}

One of the challenges of defining a domain-specific language for
testing is that test harnesses often need to perform arbitrary
computation, and programmers do not want to learn a new language.
TSTL is a template language that expands to source code in the SUT's
language, and complex functionality is handled by using the underlying
language, in this case Python.  The harness begins (lines 1-2) with
{\tt import} statements to load any needed Python modules, including
the actual SUT, the {\tt avl} module.  TSTL lines beginning with an
``@'' indicate raw Python code.  TSTL processes such lines in some
cases (for example, reimporting any modules when the SUT is
re-initialized to its starting state), but in general simply
reproduces them in compiled output.  

Lines 3-19 define two utility functions for testing.  The first of
these checks that the AVL tree in question satisfies the AVL guarantee
that a tree will be balanced. It also checks that after the height
computation, the tree's inorder traversal is unchanged from its value
at function entry.  TSTL automatically expands this into the
equivalent Python code, caching {\tt PRE} expressions used multiple
times in the body.  The {\tt it} function returns an ``inorder
traversal'' of the Python set used as a reference implementation for the AVL
tree.

\subsection{Section 2: Preamble}

Lines 20-26 define some basic properties of the test harness.  First,
line 20 tells TSTL that the {\tt avl.py} file contains all source code
on which coverage should be collected.

Lines 21-23 define the \emph{value pools} that are used in testing
\cite{AndrewsTR,UDITA}.  A test in TSTL is a sequence of assignments
and calls, and the value pool contains the values used.  A pool value
consists of a name (e.g. {\tt \%INT\%}), an integer noting how many
different values of that pool are available (here, the harness can
remember up to 4 different {\tt INT}s), and, optionally, the keyword
{\tt REF} indicating that two copies of all pool values of this type
are to be maintained, one for the SUT itself and one as a reference
implementation for differential testing \cite{Differential,ICSEDiff}.
Pool values are always set off in ``\%'' characters to distinguish
them from actual Python variables, since pool values potentially
represent several actual Python variables, and are used by TSTL to
define the graph structure of a test, as explained in Section \ref{sec:actions}.
Here the AVL trees are maintained as a reference pool, since we want
to automatically test that the AVL tree implements a set.

Line 24 tells TSTL that if the logging level is at least 1, the
inorder traversal of every AVL pool should be printed after each test
action.

Lines 25 and 26 declare the properties that must be invariantly true
after each test action: first, the height of every AVL tree must be
ok, as defined by our Python function, and second the AVL
implementation's own function for ensuring it is balanced must return
{\tt True}.  Recall that our harness maintains two AVL pool values, so
TSTL checks these properties for each AVL tree in the pool.

\subsection{Section 3: Actions}
\label{sec:actions}

Lines 27-34 are the heart of the harness definition, the actual steps
that can be taken in a valid test.  Lines 27-28 allow the construction
of arbitrary length lists of integers.  Line 29 defines the range of
integers allowed in the {\tt INT} pool, using the {\tt \%[..]\%}
construct.  Lines 30 and 31 provide for initialization of AVL trees,
either with the constructor for an empty tree or the constructor that
takes a list and produces an AVL tree containing all elements in the
list.  Lines 32-36 allow the basic AVL tree API calls --- insertion,
deletion, searching, inorder traversal, and printing.  Note that code can be
proceeded by a list (in curly braces) of exceptions to be expected as possible valid
behavior.  The two most interesting recently added features shown here are 1) that
guards can be defined by a user, limiting the conditions in which an
action is enabled, using the syntax {\tt guard -> action} and 2) a check
to perform after an action has been performed (which can include use
of {\tt PRE}) can be provided, using the syntax {\tt action =>
  check}.  This code also uses the ability to back (or forward)
reference the pool variable chosen in an expansion, e.g. {\tt \%INT,1\%}
is expanded to the same INT used in the first ``normal'' pool
reference in the action.

In large part, this section of the harness is just Python
code, with one line for each action.  The TSTL compiler is responsible
for producing a valid graph definition based on the pool values used
from this code.  Actions using a pool value are not enabled until the
pool is initialized --- lines with an assignment using {\tt :=} define
initializations.  Furthermore, a pool value cannot be re-initialized
until it has been used in some other action, to avoid useless test
sequences such as assigning first 1 and then 5 to the same {\tt INT}
pool value.  The use of a ``\verb|~|'' before a pool value use indicates that
this usage should not enable re-initialization.  Appending an item to
a LIST, for example, does not ``use it up'' but constructing an AVL
tree from a list allows that list pool value to be re-initialized.  AVL
trees cannot be over-written until they have been traversed at least
once.


\subsection{Section 4: Reference Definition}

One of the most convenient features of TSTL is its integrated support
for differential testing, where the SUT's behavior is compared to that
of a reference implementation \cite{Differential,ICSEDiff}, and
differences are reported as bugs.  Differential testing is a powerful
method for finding bugs in software ranging from simple container
classes to optimizing compilers \cite{CSmith}, but its implementation
in a testing system often requires writing a large amount of
repetitive, and sometimes subtle, code.  TSTL allows a harness to
indicate, using textual patterns, how calls to the SUT are to be
transformed into calls to a reference, and which return values from
the SUT and reference should be compared for equivalence.

Lines 37-42 show that to create a reference for an AVLTree, the
matching constructor (either taking no argument or a list) should be
called in Python's built-in {\tt set} class.  AVL insertion is handled
by the {\tt add} method for sets, and deletion with {\tt discard}.
AVLTree {\tt find} is equivalent to the {\tt \_\_contains\_\_} method
on Python sets, and an inorder traversal (sorted list of elements) is
provided by our {\tt it} function.  Note that the last reference
definition, on line 41, has to use regular expressions to transform an
AVLTree method call into a function call on the reference set.  There
is also, as shown in line 42, syntactic sugar for this transformation
(or the opposite). Finally, lines 43 and 44 tell TSTL that whenever an
action containing a {\tt find} call or an {\tt inorder} call is
performed, the return values for the operation on the SUT should be
compared to the operation on the reference.  If there is no {\tt
compare:} indicator, return values of calls are not compared, the more
typical case for many reference operations (e.g. our AVLTree's {\tt add} does not
return the same type as set's {\tt insert}, so comparison is not
possible).

\subsection{Using the Harness}

In order to test {\tt avl.py}, a TSTL user would first compile the
harness by typing: {\tt tstl avl.tstl}.  The {\tt tstl} tool takes
several command line arguments, such as the class and Python file to
output, and whether to include code coverage instrumentation, but by
default compiles the given file into {\tt sut.py} and makes a class
called {\tt sut}.  The self-contained file {\tt sut.py} produced from
our example harness is over 7,000 lines of Python code (this includes
actual testing code plus support code common to all TSTL-generated
harnesses).  If the random tester in Figure \ref{fig:rt} is in a file
called {\tt rt.py} the user can then test the AVL implementation (or
any other SUT compiled into {\tt sut.py}) by typing: {\tt python
  rt.py}.  If the AVL tree code has a bug, it is likely the tool will
quickly detect it and print out a short test case that exposes the
problem.  The TSTL release includes some simple testers, including a
much more configurable random tester than is shown here, a rudimentary
model checker, and machine-learning-based algorithms for
testing (e.g. a variant of beam search \cite{NFM15}).

\section{Related Work}


To our knowledge, there has been no previous tool providing similar
functionality.  
There exist various testing tools and languages of a somewhat
different flavor: e.g. Korat \cite{Korat}, which has a much more fixed
input domain specification, or the tools built to support the Next
Generation Air Transportation System (NextGen) software
\cite{TameInputs}.  The closest of these is the UDITA language
\cite{UDITA}, a Java extension with non-deterministic choice
operators and {\tt assume}, which yields a different language but
shares some of TSTL's goals.  TSTL aims more at the \emph{generation} of
tests than the \emph{filtering} of tests (as defined in the UDITA
paper), while UDITA supports both approaches.  This goal of UDITA (and
resulting need for first-class {\tt assume}) means that it is hosted
inside a complex tool, JPF
\cite{JPF2}, rather than generating a stand-alone simple interface to
an SUT.  Building a version of UDITA for a new language is
far more challenging than porting TSTL.  UDITA also supports many fewer
constructs to assist test harness development; e.g., users must
implement their own logging, delta-debugging, and must write what
looks like harness code.
Work at JPL on languages for analyzing spacecraft telemetry
logs \cite{scriptstospecs} is a working example of a
Python-based declarative language for testing purposes.  The pool
approach to test case construction is derived from work on canonical
forms and enumeration of unit tests \cite{AndrewsTR}.

\section{Conclusions and Future Work}

TSTL is currently a useful working prototype, capable of
production-quality testing.  We do expect that the experience of more
users will introduce some changes in the language and interface.  Our
hopes for TSTL are threefold.  First, we hope that TSTL can provide an
easy way for non-academic developers to use automated testing in their
own work, without much effort, and to take advantage of the work of
testing researchers, who will provide TSTL tools for their testing
algorithms.  Second, we hope that TSTL can serve as a way for students
to learn about automated testing, since Python is now one of the most
popular introductory languages in computer science \cite{PythonPop}.
Finally, TSTL can provide a way for researchers to rapidly prototype
new testing algorithms, and apply them with ease to any SUTs for which
a TSTL harness has been defined.  Writing meta-analysis tools to
automatically apply multiple algorithms (or the same algorithm with
different parameters) to TSTL SUTs and statistically analyze the
results is fairly easy, and we have some rudimentary scripts for this
purpose already in place in our own environment.

The next step for TSTL is to move beyond Python to provide testing
support for other languages.  Scala, Ruby, and other scripting
languages are obvious targets (we believe a Scala implementation would
be a relatively easy effort, and perhaps allow integration with
sophisticated log analysis tools \cite{KlausTool}).  Java, C, and C++
may require somewhat more complex implementations, but should also be
possible.  Finally, we believe TSTL can also target harnesses for
model checkers such as CBMC \cite{CBMCp} and SPIN \cite{SPIN}.

{\bf Acknowledgments:} The authors would like to thank the students
  (especially Francis Vo) in winter term 2015 sections of CS 362 and
  562 at Oregon State University for their comments, contributions,
  and complaints about TSTL.  A portion of this research was funded by
  NSF CCF-1217824 and NSF CCF-1054876.

\bibliographystyle{abbrv}
\bibliography{bibliography}

\newpage

\begin{comment}
\appendix

\section{Tool Demonstration}

The demonstration will consist of several main parts, based on the AVL example
given in the paper.

The first portion of the demonstration will introduce the problem of
writing a test harness.

\begin{enumerate}
\item First, we will show the audience a hand-created random tester
  for the AVL tree, with some of the features of our example.  This
  will show how hard to read and maintain such code is, as well as how
  repetitive it tends to be.
\item Then the TSTL harness will be displayed, and a brief explanation
  of each section will be given, as in the paper.
\end{enumerate}

Next, we will explain that the declarative style allows us to write a
testing tool that will work for more than one SUT, separating the
problems of defining valid tests and actually choosing which tests to
run.  This part will also show the ability of TSTL to automatically
report coverage.

\begin{enumerate}
\item We will show the random tester from the paper, with a few
  modifications to produce more readable output and to save tests in a
  file (this is supported by TSTL).
\item The demonstrator will compile the TSTL file, and quickly show
  the resulting Python class.
\item Next, we will run random testing on the TSTL file and show how
  coverage increases rapidly at first, then increasingly slowly,
  before saturating.
\end{enumerate}

Next, how to change the harness will be shown, and an example shown to
explain further how TSTL works.

\begin{enumerate}
\item A quick change to the harness will blow up the range of
  integers, and we will show how coverage increases more slowly in
  this case.  
\item Restoring the reasonable range of integer values is the next
  step, followed by a brief discussion of TSTL's limitations with very
  large branching factors.  The sizes of the compiled Python will be
  compared.
\end{enumerate}

The final demonstration portion will show that TSTL can be used to
debug a program, with delta debugging, logging, and other useful
features.

\begin{enumerate}
\item Next, we will introduce a bug into the AVL tree code, possibly
  guided by the audience.
\item Running the random tester (without recompiling the TSTL harness)
  will detect the bug.  We'll comment out reduction and show the
  initial test size, then add reduction back in and discuss how easy
  it is to use delta debugging with TSTL.
\item Next, we'll demonstrate the logging facility by having tests
  show the current tree contents at every step, by modifying the
  random tester.
\end{enumerate}

Finally, the audience will be shown how to download TSTL and
  invited to submit their own feature requests and example harnesses.

This demonstration will focus mostly on the basic idea of TSTL and its
overall use, not the technical details of the language or tool.

Figure \ref{fig:code} shows some of the actual code produced by
running TSTL that will be shown to the audience.

\begin{figure}
\begin{code}
import copy
import traceback
import re
import sys
import coverage
import avl
import math
def heightOk(tree):
    \_\_pre = \{\}
    \_\_pre['tree.inorder()'] = tree.inorder()
    h = tree.tree\_height()
    l = len(tree.inorder())
    if (l == 0):
       return True
    m = math.log(l,2)
    assert(\_\_pre['tree.inorder()'] == 
           tree.inorder())
    return h <= (m + 1)
def items(s):
    l = []
    for i in s:
       l.append(i)
    return sorted(l)
class sut(object):
    def act0(self):
        if self.\_\_collectCov:
            self.\_\_cov.start()
        try:
            self.p\_LIST[0]=[]

        finally:
            if self.\_\_collectCov:
                self.\_\_cov.stop()
                self.\_\_updateCov()
        self.p\_LIST\_used[0]=False
    def guard0(self):
        return (((self.p\_LIST\_used[0]) or 
               (self.p\_LIST[0] == None)))
\end{code}
\caption{Code from AVL harness.}
\label{fig:code}
\end{figure}
\end{comment}

\end{document}


